# Copyright 2024 The HuggingFace Team. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
import enum
import functools
import importlib
import inspect
import operator
import re
from enum import Enum
from functools import lru_cache
from typing import Callable

from packaging.requirements import Requirement
from packaging.version import Version


class Extras(enum.Enum):
    MULTILINGUAL = "multilingual"
    EXTENDED = "extended"


@lru_cache()
def is_package_available(package_name: str | Extras):
    if package_name == Extras.MULTILINGUAL:
        return all(importlib.util.find_spec(package) is not None for package in ["stanza", "spacy"])
    if package_name == Extras.EXTENDED:
        return all(importlib.util.find_spec(package) is not None for package in ["spacy"])
    else:
        return importlib.util.find_spec(package_name) is not None


@lru_cache()
def is_multilingual_package_available(language: str):
    imports = []
    packages = ["spacy", "stanza"]
    if language == "vi":
        packages.append("pyvi")
    elif language == "zh":
        packages.append("jieba")

    for package in packages:
        imports.append(importlib.util.find_spec(package))

    return all(cur_import is not None for cur_import in imports)


def raise_if_package_not_available(package_name: str | Extras, *, language: str = None, object_name: str = None):
    prefix = "You" if object_name is None else f"Through the use of {object_name}, you"

    if package_name == Extras.MULTILINGUAL and not is_multilingual_package_available(language):
        raise ImportError(prefix + not_installed_error_message(package_name)[3:])

    if not is_package_available(package_name):
        raise ImportError(prefix + not_installed_error_message(package_name)[3:])


def not_installed_error_message(package_name: str | Extras) -> str:
    if package_name == Extras.MULTILINGUAL:
        return "You are trying to run an evaluation requiring multilingual capabilities. Please install the required extra: `pip install lighteval[multilingual]`"
    elif package_name == Extras.EXTENDED:
        return "You are trying to run an evaluation requiring additional extensions. Please install the required extra: `pip install lighteval[extended] "
    elif package_name == "text_generation":
        return "You are trying to start a text generation inference endpoint, but TGI is not present in your local environement. Please install it using pip."
    elif package_name in ["bitsandbytes", "auto-gptq"]:
        return f"You are trying to load a model quantized with `{package_name}`, which is not available in your local environement. Please install it using pip."
    elif package_name == "peft":
        return "You are trying to use adapter weights models, for which you need `peft`, which is not available in your environment. Please install it using pip."
    elif package_name == "openai":
        return "You are trying to use an Open AI LLM as a judge, for which you need `openai`, which is not available in your environment. Please install it using pip."

    return f"You requested the use of `{package_name}` for this evaluation, but it is not available in your current environement. Please install it using pip."


class DummyObject(type):
    """
    Metaclass for the dummy objects. Any class inheriting from it will return the ImportError generated by
    `requires_backend` each time a user tries to access any method of that class.
    """

    is_dummy = True

    def __getattribute__(cls, key):
        if (key.startswith("_") and key != "_from_config") or key == "is_dummy" or key == "mro" or key == "call":
            return super().__getattribute__(key)

        for backend in cls._backends:
            raise_if_package_not_available(backend)


class VersionComparison(Enum):
    EQUAL = operator.eq
    NOT_EQUAL = operator.ne
    GREATER_THAN = operator.gt
    LESS_THAN = operator.lt
    GREATER_THAN_OR_EQUAL = operator.ge
    LESS_THAN_OR_EQUAL = operator.le

    @staticmethod
    def from_string(version_string: str) -> Callable[[int | Version, int | Version], bool]:
        string_to_operator = {
            "=": VersionComparison.EQUAL.value,
            "==": VersionComparison.EQUAL.value,
            "!=": VersionComparison.NOT_EQUAL.value,
            ">": VersionComparison.GREATER_THAN.value,
            "<": VersionComparison.LESS_THAN.value,
            ">=": VersionComparison.GREATER_THAN_OR_EQUAL.value,
            "<=": VersionComparison.LESS_THAN_OR_EQUAL.value,
        }

        return string_to_operator[version_string]


@lru_cache
def split_package_version(package_version_str) -> tuple[str, str, str]:
    pattern = r"([a-zA-Z0-9_-]+)([!<>=~]+)([0-9.]+)"
    match = re.match(pattern, package_version_str)
    if match:
        return (match.group(1), match.group(2), match.group(3))
    else:
        raise ValueError(f"Invalid package version string: {package_version_str}")


def requires(*backends):
    """
    Decorator to raise an ImportError if the decorated object (function or class) requires a dependency
    which is not installed.
    """

    applied_backends = []
    for backend in backends:
        applied_backends.append(Requirement(backend.value if isinstance(backend, Extras) else backend))

    def inner_fn(_object):
        _object._backends = applied_backends

        if inspect.isclass(_object):

            class Placeholder(metaclass=DummyObject):
                _backends = applied_backends

                def __init__(self, *args, **kwargs):
                    for backend in self._backends:
                        raise_if_package_not_available(backend.name, object_name=_object.__class__.__name__)

            Placeholder.__name__ = _object.__name__
            Placeholder.__module__ = _object.__module__

            return Placeholder
        else:

            @functools.wraps(_object)
            def wrapper(*args, **kwargs):
                for backend in _object._backends:
                    raise_if_package_not_available(backend.name, object_name=_object.__name__)
                return _object(*args, **kwargs)

            return wrapper

    return inner_fn
